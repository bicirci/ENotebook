  
#  静态库和动态库的实现
  
  
##  1. 静态库和动态库的核心概念
  
  
静态库是.o文件的打包文件, 内部包含的每一个.o文件的官方说明是可重定位文件（Relocatable File）, 是Linux下ELF（Executeable and Linkable Format，可执行与可链接格式）格式的第一种类型.  
  
![静态库和动态库的引用-2021-10-26-elf1](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的引用-2021-10-26-elf1.png )
  
每一个.o文件都是由一个一个的section组成,开头的ELF Header对整个文件进行了大致的描述, 并指导系统找到Section Header Table的位置.  
  
Section Header Table 描述了每一个节的名称,大小,位置等信息. **编译器,链接器等都是通过这个表来定位和访问各个节的**  
  
动态库.so文件则是ELF的第二种格式, 相较于静态库, 其seciton节的数量会更多, 包含的信息也更多.  
  
![静态库和动态库的引用-2021-10-27-elf2](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的引用-2021-10-27-elf2.png )
  
这里介绍几个比较关键的节信息:  
  
1. .text节: 代码节,保存交给cpu执行的一句一句的机器码  
2. .rodata节: read only data, 保存字符串等只读数据  
3. .data节: 保存程序已初始化的全局变量数据  
4. .bss节: 保存未初始化的全局变量.该节在实际的ELF文件中是不存在的(Section Header Table中对该节的offset填空值), 只有当程序执行时,才会在内存中分配一段空间给.bss节用以保存所有未初始化的全局变量  
5. .symtab节: 符号表. 程序内的所有的符号都在这一节进行记录.程序链接时需要读取这一节数据.每一个符号, 名字的长度都各不相同, 为了尽量对齐保存时使用的空间,将每个符号的名字单独隔离成一节,也就是后文的.strtab节. 符号表里的符号名称保存的都是对应在.strtab节中的索引值.  
6. .dynsym节: 同样也是符号表,只不过这一节是将symtab中引用的外部符号再单独保存一份, 从而可以在运行时载入内存,供动态链接时调用.  
7. .strtab和.dynstr节: 字符串表,内部就是一个一个头尾相接的字符串.要注意的是该部分是不载入到内存中的,是专门用于保存符号表的显示("_Z4basev"......)和节名(".text"......)的显示用的字符.实际程序运行时打印的字符串都是保存在.rodata节内的. .strtab和.dynstr分别对应.symtab和.dynsym所需的字符.  
8. .shstrtab节: (section header strtab) 此节不是必须的.某些系统可能会将.strtab中用于保存节名(".text", ".data"......)的部分单独隔离开来形成这一个单独的节.  
9. .rel.text及其他.rel.*: 主要跟静态库以及.o文件的链接相关,具体会在后问描述.
  
##  2.链接的核心概念
  
  
这里先暂时略过动态库的链接过程, 主要从静态库和.o文件的角度描述. 链接就是将一个个的.o文件合并成一个ELF的第三种类型, 也就是应用程序. 在合并的过程中就需要将对应的节整理到一起, 并处理外部引用的变量和函数.  
  
1.合并节
假设有a.o文件和b.o文件, 他们内部各有.text, .symtab, .data节. 以.data节中的变量为例, 当a.o中存在apple(2字节)和banana(4字节)两个变量, b.o中存在orange(2字节变量), 假设合并时拼接的.data节中a.o的部分在前, b.o的部分在后, 那么经过链接器的合并操作,完成了以下的修改:  
![静态库和动态库的引用-2021-10-27-elf3](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的引用-2021-10-27-elf3.png )
  
* 填写最终生成的ELF文件内合并而成的.data节的起始位置, 大小和载入内存时的虚拟地址  
* 填写新的.symtab符号表内apple banana orange(由0->6)的符号对应的位置  
* 将.text代码段中调用的内部变量的位置一一替换为新位置.比如原先代码中对orange的操作是`mov 0x00 <img src="https://latex.codecogs.com/gif.latex?1`,%20现在就需要修改为`mov%200x06"/>1`(orange的新位置)  
* 查找外部引用的变量, 并填写对应的位置.(重定位)  
  
2.重定位
上文的最后一点就要跟前文的.rel.text联系上. 假设a.o中的代码使用了orange变量, 那么在a.o的符号表中,该变量是一个外部引用符号,其位置地址填空. .text代码段中对orange变量的操作也都把地址填空. `add 0x00 //add orange`  
同时, 在.rel.text节会记录一条orange的记录,其数据格式为:  
  
``` C
typedef struct {
  Elf32_Addr r_offset;  /* 需要重定位的位置, 即add 0x00中的0x00这一处在.text节的offset地址 */
  Elf32_Word r_info;  /* orange变量在符号表中的索引(高24位)以及重定位类型(低8位),不同类型的偏移规则略有不同 */
} Elf32_Rel;
```
  
在链接器把新的.data段合并完成后,更新好符号表了,链接器就会根据.rel.text节中记录的orange的引用记录,查找符号表中orange分配的内存位置为0x06, 把.text代码中填写的0x00替换成真实的0x06 `add 0x06 //add orange`, (真实情况下应该是该数据分配的虚拟地址), 完成重定位的操作.  
  
要注意的是, 每一处对orange的使用都会新增一条重定位记录.链接器要根据.rel.text每一条记录,对应修改.text节中的外部变量地址.  
  
类似的,如果.data数据段中, 有指针类的数据指向了外部的数据, 如`int *p = &orange;`. 那么就会生成一个.rel.data节, 并在里面添加一条记录, 从而在重定位期间将p的值由0x00替换为0x06.  
  
##  3.动态库的链接过程
  
  
动态库的链接过程较为复杂, 与静态库相比, 一部分工作是由链接器完成, 但大部分的核心实现则是在程序运行前由加载器执行的.  
  
首先要明确的基本概念是, 动态库的产生是为了优化多进程使用同一份静态库内容时,每个进程在运行时其内存中都包含了相同的代码内容,造成了内存的浪费.其核心需要解决的是代码的复用.  
而库的数据段则是不共享的, 也就是运行时, 在虚拟内存中载入的动态库, 其代码段是指向在物理内存中的同一处, 而数据段则是每个进程都占用一块独立的物理内存的.  
  
![静态库和动态库的引用-2021-11-02-lib](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的引用-2021-11-02-lib.jpg )
  
1.编译链接阶段
  
* 我们先假设用静态库相同的方法处理动态库. 当链接时, 如果a.o文件引用了libA.so内的一个全局变量, 那么在重定位时, 就需要将代码中填入真实的地址.  
简单的做法当然是定死一个虚拟地址给这个变量, 在程序运行前加载器工作时, 指示加载器必须将这个变量加载到该位置, 可动态库在实际加载时, 是由mmap动态申请内存块来存放的, 其地址根据堆栈的使用, 加载动态库的顺序的不同,都有可能变化. 那么这个分配死的虚拟地址如果因为加载顺序的不同被其他的动态库占用了, 就无法继续加载.  
为了解决这一问题, 引入了==GOT section(global offset table)==. GOT段位于可修改的数据段,也就是.data, .bss的前后, 它就是一张指针表, 代码中使用动态库的全局变量时, 就在GOT段新建一项, 让代码使用这项指针指向的变量内存. 而在程序运行前, 加载器就需要对应的动态库加载好, 并将这个变量的位置填写到GOT的表项中.比如 `lib_a ++` 在编译时实际生成的代码是类似`add got[1] 1`.  
  
* 解决了外部程序调用动态库内的全局变量这一问题后, 我们再接着考虑动态库本身. 已知动态库是可能被加载到不同位置的, 那么动态库的数据段的位置是不确定的. 动态库本身代码段的代码在调用内部的全局变量时, 假设`apple++`是 `ADD 0xXXXX 1`, 这个0xXXXX在代码中具体应该怎么填写? 可行的方案是通过相对位置或者是前面说的GOT方案.  
相对位置方案可行是因为在载入动态库时肯定是申请的一整块内存, 代码段和数据段是连续存放的, 那么就可以通过相对位置索引到这个变量值.比如前面说的`ADD 0xXXXX 1` 实际可能会被编译器解释为如下的多句汇编语言(以下伪代码仅供参考)  
  
``` C
get addr //获取运行时该行代码的内存地址;
add addr 0x1234 //通过相对位置找到apple的位置, 0x1234是编译阶段就可以确定的相对偏移量, 可以直接写入代码中;
add *addr 1 //通过addr对应的地址, 实现对数据段中这个变量的操作
```
  
* 但如果外部的程序也调用了这个变量值该怎么办呢? 还是照着前文说的, 在外部程序的GOT表中标记此项. 但是这样处理, 会出现同一个符号存在GOT定位和相对位置定位的并存情况, 这样不太便于管理. 因此实际的编译过程中, 如果发现该变量是==static静态==的, 那么就可以用相对位置进行处理. 而如果该变量是==全局==的, 那么以防存在外部调用, 统一采用GOT的方式, 哪怕是库内部代码对该变量的调用也通过在动态库内建立GOT表来经过指针引用.  
但此时的GOT调用依然需要考虑到动态库可能任意位置加载的情况, 因此和可执行程序中的GOT方式略有不同.  
  
*可执行程序引用动态库内的全局变量*:  
  
``` C
lib_a ++; 
==>
mov addr 0x6789 //直接找到GOT[1]的位置, 0x6789是编译阶段就可以确定的可执行程序内GOT表内GOT[1]表项的位置;
add &addr 1 //通过索引GOT[1]对应的地址, 实现对数据段中这个变量的操作 add got[1] 1
```
  
*动态库内引用自己的全局变量*:  
  
``` C
lib_b++;
...
lib_a ++; 
==>
get addr //获取运行时该行代码的内存地址;
add addr 0x2345 //通过相对位置找到GOT[2]的位置, 0x2345是编译阶段就可以确定的相对偏移量, 可以直接写入代码中;
add &addr 1 //通过GOT[2]对应的地址, 实现对数据段中这个变量的操作
```
  
![静态库和动态库的实现-2021-11-03-lib2](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的实现-2021-11-03-lib2.png )
  
* GOT表内保存的只是一个地址,是没有符号和位置信息的, 因此, 所有在GOT内需要进行重定位的符号, 都会在rel.dyn的表项内(和rel.text的格式类似,不过记录的是GOT内每一项的位置,对应的符号信息和重定位地址计算类型)做好记录. 从而供加载器查看(前面的相对位置的static的变量也是在这里记录的)  
  
* rel.dyn 和 .dynsym的区别是, .dynsym保存的是代码中使用到的外部的符号和位置信息, 一个符号对应一个记录, ~~而rel.dyn中则是该符号在代码中的每一次调用都要进行重定位, 因此一个符号可能对应rel.dyn中的多条记录~~ ==更正==:由于已经采用GOT,在代码段内实际已经用相对地址做索引,代码段内不需要载入时的重定位修改, 所有修改都在数据段. rel.dyn保存的则是这些需要重定位的变量符号在GOT的位置, 以及重定位的地址计算类型. dynsym是在编译阶段生成.o的时候就有的, 而rel.dyn则要到链接阶段, 链接器先读取dynsym确定哪些符号使用的是动态库, 生成了GOT后才会生成rel.dyn, 从而到加载阶段使用.  
* rel.dyn 和 rel.text的区别. rel.text是供链接器在重定位时期查看的, 而rel.dyn则是供加载器在加载阶段查看的.对于变量的每一次调用都会在.rel.text生成一条记录, 而一个变量在rel.dyn只会有一次记录, 记录的是该符号需要重定位的got表中的位置.  
其实还有一种载入时重定位的操作, 是针对指针类的数据. 比如动态库中定义了`static int a; static int* p = &a;` p这个变量在.data段的保存值在库被载入前都是未知的,所以.rel.dyn的段针对这些这些指针变量还定义了专门的type, 从而引导加载器在动态库载入时将真实的指针数据写入.  
  
2.载入阶段
  
* 在编译阶段写明了上述所需的内容后, 程序运行前会调用.interp段标识的加载器, 去加载程序所需的动态库, 并将对应的地址填写到需要重定位的字段中去.(主要工作是根据rela.dyn去填写GOT信息)  
  
3.运行阶段
  
* 运行阶段时, 加载器还有一个重要的作用是函数的延迟载入. 上面描述的都是动态库中全局变量的加载方式, 涉及到动态库中函数的加载时,情况更为复杂.  
由于实际运行中, 一次性将所有的外部函数符号进行重定位, 可能耗时较长, 实际采用的是按需调用的方式,也就是外部函数的延迟加载. 在编译阶段, 针对所有外部的函数符号,可执行程序中会加入.plt段. 它的内部是一小段一小段标准化的可执行代码, 但却是在运行时可以修改的,属于数据段的内容.  
.plt 和 .got是需要互相配合的. 当链接器确定一个外部符号来自动态库后, 会在got段添加一项, 同时也在.plt段添加一项, 并使得got的新增项的默认值指向.plt新增项的==第二句==. 而代码中的这个函数调用所用的函数指针, 就指向.plt段的新增项. 在编译阶段生成的.plt的标准化格式如下:  
  
``` c
fun@plt:
0x1001    jmp *(fun@got.plt)
0x1002    push index
0x1003    jmp _init
```
  
* 在编译阶段 fun@got.plt(got表中该函数的对应表项地址) 的值,即got表项内初始化时保存的默认值, 就是==第二句==push index的地址0x1002, 这也就是延迟载入的关键.  
当函数第一次被调用时,通过绝对地址(可执行程序内)/相对位置(动态库内)调用fun@plt, 执行第一句跳转到 got[index] 所保存的地址,也就是 0x1002, 也就是跳到下一句 push index. 之后 push index 就将该函数在 got 中对应的索引号作为参数传给 _init 执行, 而_init 正是加载器用来定位库函数位置的代码, 它会找到该库函数的真实位置, 将原先got表中指向push index的地址0x1002修改为该动态库函数的实际位置. 这样, 当应用运行时再度调用这一函数时, 就通过fun@plt的第一句, 从而可以直接跳转到函数的位置了.  
![静态库和动态库的实现-2021-11-03-lib3](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的实现-2021-11-03-lib3.png )
![静态库和动态库的实现-2021-11-03-lib4](https://cdn.jsdelivr.net/gh/bicirci/PicBed@master/MarkDown/静态库和动态库的实现-2021-11-03-lib4.png )
  
* 这些供延迟加载使用的在got节中被.plt调用的表项, 会被单独标记成.got.plt节, 其实际就是.got的一部分.  
* 和rel.dyn相类似的, 所有代码中对动态函数的调用,都会在rel.plt段生成一条记录, 供加载器查阅.  
  
* 编译动态库时使用的-fPIC选项, 就是指带的位置无关代码 position-independent code, 主要实现的就是延迟加载. 如果编译动态库时不添加该选项(部分编译器是强制必须添加-fPIC的), 可以发现生成的动态库文件中没有了.rel.plt节, 而原先位于.rel.plt节的对外部函数的重定位记录都重新在rel.dyn节重新记录, 这意味着所有的外部函数都和载入时重定位的指针类的数据一样,需要在载入时一次性全部重定位完成,再载入到内存, 丢失了got转发的步骤. 这也表示, 这段代码被载入到内存后, 只能由该进程使用, 而无法被别的进程共享了(重定位后的虚拟内存地址,不同进程位置不同, printf在库载入时被重定位为call 0x0001, 但在另一个进程, printf的位置可能在0x0002,那么这段已经被载入的代码就失去了共享功能).  
  
##  4. 强弱符号的概念
  
  
强弱符号是编译器的配置宏, 跟编程语言和编译本身无关. 如果存在相同名称的全局变量或全局函数, 那么编译阶段重定位的时候就需要确定以哪个为准. 通常已经初始化好的全局变量, 和所有的全局函数名, 都是默认的强符号. 而未初始化的全局变量默认为弱符号. 强符号优先级高于弱符号, 弱符号之间体积大的优先级较高. 如果同时存在两个强符号, 则按照标准编译器理应报错(实际可能根据编译器的版本, 有自动排序的策略)
  
``` c
//指定强弱符号
void  __attribute__((weak))  func(void);
int  num  __attribte__((weak) = 1;
```
  
##  参考链接  
  
  
1. [ELF文件结构](http://chuquan.me/2018/05/21/elf-introduce/ )  
2. [ELF内部节的详细解释](https://os.51cto.com/art/202105/663698.htm )  
3. [动态库加载的汇编码分析](https://www.cnblogs.com/catch/p/3857964.html )  
4. [位置无关代码](http://ybin.cc/compiler/position-independent-code-in-shared-library/ )  
5. [理解 Linux 位置无关代码 PIC](https://www.cnblogs.com/Linux-tech/p/13873886.html )  
  